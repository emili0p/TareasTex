\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xcolor}

\geometry{margin=2.5cm}

\title{Documento de Uso y Organización de la Aplicación}
\author{Análisis y diseño}
\date{\today}

\begin{document}

\maketitle

\section{Introducción}
El presente documento tiene como objetivo describir la arquitectura de la aplicación, justificar la elección de las tecnologías utilizadas, y establecer los estándares y la estructura de trabajo en el repositorio del proyecto.

\section{Tecnologías Elegidas}
La aplicación se desarrolla con un \textbf{backend monolítico en Laravel} y un \textbf{frontend en Vue.js}, siguiendo un patrón de comunicación mediante \textbf{API REST} el cual nos permitira comunicar diferentes partes de la aplicacion con peticiones en htt el cual nos permitira comunicar diferentes partes de la aplicacion con peticiones en http. 

\subsection{Justificación del Frontend}
Se eligió \textbf{Vue.js} por las siguientes razones:
\begin{itemize}
    \item Es un framework que presenta una alta compatibilidad con Laravel, facilitando la integración entre frontend y backend.
    \item El equipo de frontend ya posee experiencia en \textbf{JavaScript}, lo que reduce la curva de aprendizaje al parecerce a otros frameworks de JavaScript que se han utilizado con anterioridad en el frontend acelerando asi  el desarrollo.
    \item Permite construir aplicaciones SPA (Single Page Application) con componentes reutilizables (esencial dado que varios modulos se repetiran) y fácil mantenimiento.
\end{itemize}

\subsection{Justificación del Backend}
El \textbf{backend en Laravel} fue seleccionado considerando:
\begin{itemize}
    \item El equipo ya ha trabajado con \textbf{PHP} y conexión a bases de datos relacionales en materias anteriores, lo que hace sencilla la adopción de Laravel.
    \item Laravel proporciona una estructura organizada de \textbf{Controllers, Models y Services}, que facilita la implementación de la lógica de negocio y la gestión de rutas API.
    \item Permite integración rápida con bases de datos SQL, como \textbf{MariaDB o cualquier BD relacional, sin mucho problema de migración}.
\end{itemize}

\subsection{Base de Datos y Despliegue}
La base de datos seleccionada es \textbf{MariaDB}, la cual:
\begin{itemize}
    \item Es compatible con Laravel mediante Eloquent ORM.
    \item Se puede desplegar de forma contenerizada junto con la aplicación, permitiendo pruebas rápidas y entornos reproducibles.
    \item Facilita la administración y migración de datos durante el desarrollo y pruebas.
\end{itemize}
\section{Arquitectura del Sistema}

\subsection{Modelo Arquitectónico}

Se adopta una arquitectura de tipo \textbf{Monolito Modular}, donde el backend se organiza por dominios funcionales (Students, Teachers, Subjects, Grades, Auth). Cada módulo encapsula:

\begin{itemize}
    \item Controladores (capa HTTP)
    \item Servicios (lógica de negocio)
    \item Modelos (persistencia)
    \item Requests (validaciones)
    \item Policies (autorización)
    \item Resources (transformación de salida JSON)
\end{itemize}

Este enfoque permite alta cohesión interna y bajo acoplamiento entre módulos.

\subsection{Flujo de una Petición}

\begin{enumerate}
    \item Cliente realiza petición HTTP.
    \item Laravel recibe la petición mediante rutas API.
    \item Se ejecuta validación mediante Form Request.
    \item El Controller delega la lógica al Service correspondiente.
    \item El modelo interactúa con la base de datos.
    \item Se retorna respuesta estructurada mediante API Resource.
\end{enumerate}

\subsection{Versionado de API}

Todas las rutas estarán bajo el prefijo:

\begin{verbatim}
/api/v1/
\end{verbatim}

Esto permite mantener compatibilidad futura en caso de evolución del sistema.

\subsection{Justificación del Backend}
El \textbf{backend en Laravel} fue seleccionado considerando:
\begin{itemize}
    \item El equipo ya ha trabajado con \textbf{PHP} y conexión a bases de datos relacionales en materias anteriores, lo que hace sencilla la adopción de Laravel.
    \item Laravel proporciona una estructura organizada de \textbf{Controllers, Models y Services}, que facilita la implementación de la lógica de negocio y la gestión de rutas API.
    \item Permite integración rápida con bases de datos SQL, como \textbf{MariaDB o cualquier BD relacional, sin mucho problema de migración}.
\end{itemize}
\section{Estándares de Código}

\subsection{Backend (Laravel)}

El código backend deberá cumplir con el estándar \textbf{PSR-12} para garantizar consistencia y mantenibilidad de la base de codigo.

\subsubsection*{Convenciones Generales}

\begin{itemize}
    \item Indentación de 4 espacios.
    \item Clases en formato PascalCase.
    \item Métodos y variables en camelCase.
    \item Nombres descriptivos y semánticos coherentes.
    \item No se permiten variables ambiguas (ej. \$data, \$tmp, \$prueba, \$algo, \$s = numero magico,).
\end{itemize}

\subsubsection*{Organización Arquitectónica}

\begin{itemize}
    \item Los Controllers no deben contener lógica de negocio pues realizaran otras funciones y el objetivo es que sea modular.
    \item Toda lógica de negocio debe implementarse en Servicios.
    \item Las validaciones deben implementarse mediante Form Requests.
    \item La autorización debe centralizarse en policies de seguridad.
    \item Las respuestas JSON deben estructurarse usando API Resources para respuestas con sentido.
\end{itemize}

\subsubsection*{Buenas Prácticas}

\begin{itemize}
    \item Uso obligatorio de tipado estricto cuando sea posible es decir no declarar cosas magicamente.
    \item Uso de transacciones para operaciones críticas, evitando inyecciones de SQL.
    \item Manejo consistente de excepciones para detectar errores .
    \item Prohibido acceso directo a la base de datos desde controladores, quitando vulnerabilidades.
\end{itemize}

\subsection{Frontend (Vue.js)}

\subsubsection*{Convenciones Generales}

\begin{itemize}
    \item Componentes en PascalCase.
    \item Separación clara entre lógica y presentación.
    \item Uso obligatorio de ESLint y Prettier para un codigo consistente.
    \item Manejo de estados bien documentados.
\end{itemize}

\subsubsection*{Organización}

\begin{itemize}
    \item Estructura modular por dominio funcional.
    \item Separación entre componentes reutilizables y vistas.
    \item Llamadas HTTP centralizadas en carpeta api/.
\end{itemize}

\subsection{Herramientas de Calidad}

\begin{itemize}
  \item Backend: Laravel Pint para formateo automático (disponible en vscode).
  \item Backend: PHPStan para análisis estático (disponible en vscode).
    \item Frontend: ESLint y Prettier para consistencia.
    \item Integración de validación automática en Pull Requests.
\end{itemize}

\section{Seguridad y Control de Acceso}

El sistema implementará los siguientes mecanismos de seguridad:

\begin{itemize}
    \item Autenticación basada en tokens.
    \item Autorización basada en roles (ADMIN, DOCENTE, ALUMNO).
    \item Middleware para protección de rutas sensibles para que no sean incertepcetadas.
    \item Validación obligatoria en todas las entradas de datos.
    \item Manejo estandarizado de errores HTTP (200,400,501, etc).
\end{itemize}

Se restringirán métodos HTTP inseguros como TRACE.
\section{Estrategia de Testing}

Se implementarán los siguientes tipos de pruebas:

\begin{itemize}
    \item Pruebas Unitarias para lógica de negocio en Services.
    \item Pruebas de Integración para endpoints REST, para asegurar que los datos devueltos son concisos.
    \item Validación automática en Pull Requests mediante ejecución de tests de Github actions.
\end{itemize}

Una funcionalidad no podrá integrarse a producción sin pasar las pruebas automatizadas.
\section{Principios Arquitectónicos}

La arquitectura del sistema se basa en los siguientes principios:

\begin{itemize}
    \item Separación de responsabilidades de cada zona del desarrollo.
    \item Alta cohesión.
    \item Código mantenible legible y extensible.
    \item Minimización del riesgo técnico que podria generar una gran deuda tecnica.
\end{itemize}
\section{Riesgos Técnicos y Mitigación}

\begin{itemize}
    \item \textbf{Riesgo:} Baja experiencia avanzada en Vue. \\
    \textbf{Mitigación:} Estándares de código estrictos y revisión cruzada.

    \item \textbf{Riesgo:} Crecimiento futuro del sistema. \\
    \textbf{Mitigación:} Organización modular preparada para futura separación en microservicios.

    \item \textbf{Riesgo:} Dependencia del stack PHP. \\
    \textbf{Mitigación:} Uso de estándares REST que permiten migración futura a otro stack en Java o otra tecnologías robusta.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{/home/emilio/Descargas/arqr.drawio.png} 
    \caption{Diagrama de arquitectura del software}
    \label{fig:arquitectura}
\end{figure}

\section{Estructura del Repositorio}
Se propone una organización estándar para el repositorio Git del proyecto, con la siguiente estructura de carpetas:

\begin{verbatim}
/raiz-projecto
│
├── backend/                  # Código Laravel
│   ├── app/
│   │   ├── Http/Controllers/
│   │   ├── Models/
│   │   ├── Services/
│   │   └── Repositories/
│   ├── routes/
│   ├── database/
│   │   ├── migrations/
│   │   └── seeders/
│   └── config/
│
├── frontend/                 # Código Vue.js
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── router/
│   │   └── store/
│   └── public/
│
├── docker/                   # Archivos para contenerización
│   ├── Dockerfile.backend
│   ├── Dockerfile.frontend
│   └── docker-compose.yml
│
├── tests/                    # Pruebas unitarias y de integración
├── .gitignore
└── README.md
\end{verbatim}

Esta estructura permite separar claramente el frontend y backend, facilita la contenerización y despliegue rápido de la aplicación y la base de datos, y mantiene un estándar de organización que el equipo puede seguir de manera consistente.

\section{Convenciones de Git y Flujo de Trabajo}

\subsection{Ramas (Branches)}
Para mantener un flujo de trabajo ordenado y facilitar la integración continua por lo que es vital que los desarrolladores dominen el sistema de versiones Git y sepan como funciona Github, se propone el siguiente esquema de ramas:

\begin{itemize}
    \item \textbf{main} o \textbf{master}: Rama estable que contiene la versión en producción.
    \item \textbf{develop}: Rama principal de desarrollo donde se integran las nuevas funcionalidades antes de pasar a producción.
    \item \textbf{feature/nombre-de-la-funcionalidad}: Ramas temporales para desarrollar nuevas funcionalidades. Deben crearse desde \textbf{develop} y fusionarse de vuelta a ella.
    \item \textbf{bugfix/nombre-del-bug}: Ramas temporales para corregir errores específicos.
    \item \textbf{hotfix/nombre-del-hotfix}: Ramas para correcciones urgentes sobre la rama \textbf{main}.
\end{itemize}

\subsection{Commits}
Cada commit debe ser claro, conciso y descriptivo. Se recomienda seguir el siguiente formato:

\begin{verbatim}
tipo: descripción corta
\end{verbatim}

\textbf{Tipos de commit que podrian hacerse:}
\begin{itemize}
    \item \textbf{funcionalidad}: Nueva funcionalidad.
    \item \textbf{fix}: Corrección de errores.
    \item \textbf{docs}: Cambios en documentación.
    \item \textbf{refactorización}: Refactorización de código sin agregar funcionalidades ni corregir bugs.
    \item \textbf{test}: Agregar o modificar pruebas.
    \item \textbf{mant}: Tareas de mantenimiento, configuración o dependencias.
\end{itemize}

\textbf{Ejemplo:}
\begin{verbatim}
funcionalidad: agregar endpoint para registrar usuarios
fix: corregir validación de email en el login
docs: actualizar README con instrucciones de despliegue
\end{verbatim}

\subsection{Pull Request (PR) antes de producción}
Antes de fusionar cualquier cambio a la rama \textbf{main}, se debe realizar un Pull Request siguiendo estas reglas:

\begin{itemize}
    \item La rama base del PR debe ser \textbf{develop} para integración continua, o \textbf{main} solo para hotfixes listos para producción.
    \item Título del PR: claro y descriptivo, siguiendo el formato de commit.
    \item Descripción del PR: debe incluir
    \begin{itemize}
        \item Resumen de la funcionalidad o bug corregido.
        \item Referencias a issues o tickets relacionados.
        \item Lista de cambios relevantes.
        \item Instrucciones de prueba o validación si aplica.
    \end{itemize}
    \item Todo PR debe ser revisado por al menos un lider del equipo o area antes de fusionarse con la rama principal.
    \item Realizar merge solo cuando el PR ha pasado las pruebas y la revisión de código excepto en casos especiales.
\end{itemize}
\section{¿Cuando algo esta hecho?}

Una funcionalidad se considera terminada cuando:

\begin{itemize}
    \item Cumple los estándares definidos.
    \item Incluye validaciones correspondientes.
    \item Tiene pruebas automatizadas.
    \item Fue revisada mediante Pull Request.
    \item No genera errores en análisis estático.
\end{itemize}

\section{Conclusión}
La elección de \textbf{Vue.js} y \textbf{Laravel} permite al equipo aprovechar su experiencia previa en JavaScript y PHP, garantizando una integración eficiente entre frontend y backend, facilitando  el desarrollo de nuevas funcionalidades asegurandonos rápidez y consistencia, minimizando la curva de aprendizaje de los devs.

La contenerización de la aplicación junto con la base de datos \textbf{MariaDB} permite crear entornos de desarrollo y pruebas reproducibles, agilizando la implementación de nuevas características y la ejecución de pruebas automatizadas. Esta estrategia asegura que los desarrolladores puedan levantar el entorno completo de manera sencilla y consistente, sin depender de configuraciones locales específicas.

Asimismo, la propuesta de estructura del repositorio de Git y las convenciones de trabajo (branches, commits y Pull Requests) promueven claridad, mantenibilidad y colaboración efectiva entre los miembros del equipo. Establecer un flujo de trabajo basado en ramas de desarrollo, ramas de funcionalidades y ramas de hotfix, junto con commits claros y descriptivos, asegura que los cambios se integren de forma controlada y segura antes de pasar a producción.

En conjunto, estas decisiones permiten que el proyecto sea escalable, fácil de mantener y flexible frente a cambios futuros, garantizando una base sólida tanto para el desarrollo como para el despliegue de la aplicación en entornos de producción y pruebas.
\end{document}

